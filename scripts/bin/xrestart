#!/usr/bin/env bash
# kill and (re)run a program for the current X session only

print_help() {
	echo "usage: xrestart [options] <program and args>

This kill and (re)run a program for the current X session only. See also
./xstop.

options:
    -c command  specify the program name to use with pgrep to check for existing
                pids; existing pids are ignored when determining the new pid
                (default: first positional argument)
    -n name     the name to use to store the pid; specify if you may need to use
                xrestart for multiple instances of this program (e.g. for a bspc
                subscribe) (default: first positional argument)
    -N name     specify the name and command with one flag
    -e          whether to evaluate the arguments (useful to provide a string
                with a pipe in it, for example)
"
}

command=
name=
eval=false
while getopts :c:ehn:N:: opt
do
	case $opt in
		c) command=$OPTARG;;
		e) eval=true;;
		n) name=$OPTARG;;
		N) command=$OPTARG
		   name=$OPTARG;;
		h) print_help;;
		*) print_help ; exit 1;;
	esac
done
shift "$((OPTIND-1))"

if [[ -z $command ]]; then
	command=$1
fi

if [[ -z $name ]]; then
	name=$1
fi

pidfile=/tmp/"$name"_"$DISPLAY".pid

if [[ -f "$pidfile" ]]; then
	pkill --pidfile "$pidfile" 2> /dev/null
fi


blacklist=$(pgrep "$command")

if $eval; then
	eval "$@" &
else
	"$@" &
fi

final_pid=$!

# $! is not right for xcape and dunst for example
while read -r pid; do
	if [[ ! $blacklist =~ (^|$'\n')"$pid"($|$'\n') ]]; then
		final_pid=$pid
		break
	fi
done < <(pgrep "$command")

echo "$final_pid" > "$pidfile"
